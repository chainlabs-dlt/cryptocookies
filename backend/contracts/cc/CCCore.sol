/// SPDX-License-Identifier: UNLICENSED
/// Copyright Â© 2023 Chainlabs Switzerland SA
/// All Rights Reserved

import "../wtf/WtfApp.sol";
import "../wtf/distributors/ERC20ControlDistr.sol";
import "./CCStaking.sol";
import "./CCLocking.sol";

pragma solidity ^0.8.18;

/// @title CryptoCookies' Core Contract
/// @author Chainlabs Switzerland SA
/// @notice This contract serves as the main point of access of the CryptoCookies environment.
/// Redirects the revenue generated by Wtf to a specific set of pools managed by the DAO.
contract CCCore is WtfApp {
	uint256 public constant HUGE_APPROVAL = 1 << 255;

	// CCCore can be abstracted down to "bridges" connecting Wtf's distribution contracts to
	// local pool distribution contracts (i.e. staking, locking, developer's fee, etc.).
	struct PoolBridge {
		BaseERC20Distr wtfOrigin;
		BaseERC20Distr bridge;
	}
	// Mapping of pool (i.e. locking/staking) => (wtfOrigin, bridge)
	mapping(BaseERC20Distr => PoolBridge) public bridges;
	// Keyset of bridges, pools[0] = FDG_STAKING; pools[1] = CKI_STAKING;
	// pools[i] -> locking, developer's fee, others, etc.
	BaseERC20Distr[] public pools;

	// We utilize controlled ERC20 distribution contracts as bridges to enhance flexibility
	// and ease of use. Both CCCore and CryptoCookies' DAO have control over stakes.
	ERC20ControlDistr public FDG_BRIDGE;
	ERC20ControlDistr public CKI_BRIDGE;

	/// @notice Constructs the entire CryptoCookies' environment.
	/// @param _fdgDistr Wtf's Fudge (FDG) distribution contract.
	/// @param _ckiDistr Wtf's Cookie (CKI) distribution contract.
	/// @param _admin CryptoCookies' DAO contract.
	constructor(address _fdgDistr, address _ckiDistr, address _admin) WtfApp(_fdgDistr, _ckiDistr) {
		// Setup both bridges.
		FDG_BRIDGE = new ERC20ControlDistr(address(FDG), address(this));
		FDG_BRIDGE.grantRole(FDG_BRIDGE.DEFAULT_ADMIN_ROLE(), _admin);
		FDG.approve(address(FDG_BRIDGE), HUGE_APPROVAL);

		CKI_BRIDGE = new ERC20ControlDistr(address(CKI), address(this));
		CKI_BRIDGE.grantRole(CKI_BRIDGE.DEFAULT_ADMIN_ROLE(), _admin);
		CKI.approve(address(CKI_BRIDGE), HUGE_APPROVAL);

		// Setup staking pools, with starting absolute stakes.
		_registerPool(
			new CCStaking(address(this), address(FDG), address(CKI_BRIDGE)),
			CKI_DISTR,
			CKI_BRIDGE
		);
		CKI_BRIDGE.userChangeStake(address(pools[0]), 1 ether);

		_registerPool(
			new CCStaking(address(this), address(CKI), address(FDG_BRIDGE)),
			FDG_DISTR,
			FDG_BRIDGE
		);
		FDG_BRIDGE.userChangeStake(address(pools[1]), 1 ether);
	}

	/// @dev Registers a pool to CCCore:
	/// 1. Adds to the keyset of pools
	/// 2. Creates a bridge mapping
	function _registerPool(
		BaseERC20Distr pool,
		BaseERC20Distr wtfOrigin,
		BaseERC20Distr bridge
	) internal {
		pools.push(pool);
		bridges[pool] = PoolBridge(wtfOrigin, bridge);
	}

	/// @notice Performs a CCCore update for one pool. More specifically:
	/// 1. Harvests all of the app's claimable revenue from the pool's origin.
	/// 2. Redirects obtained tokens to the pool's bridge contract.
	/// May only be called by a pool of CryptoCookies.
	/// @param _pool The pool for which to claim.
	function update(address _pool) external {
		PoolBridge storage poolBridge = bridges[BaseERC20Distr(_pool)];

		uint256 claimed = poolBridge.wtfOrigin.claim();
		poolBridge.bridge.inject(claimed);
	}
}
